// @vitest-environment node
import { describe, it, expect } from 'vitest'

/**
 * Tests for invite code generation logic
 *
 * In production, invite codes are generated by PostgreSQL:
 * encode(gen_random_bytes(6), 'hex') = 12 hex characters
 *
 * This gives us 16^12 = 281,474,976,710,656 possible codes (~281 trillion)
 * With UNIQUE constraint in database, collisions are impossible
 */

describe('Invite Code Format', () => {
  // Simulate the PostgreSQL function for testing
  const generateInviteCode = (): string => {
    const bytes = new Uint8Array(6)
    crypto.getRandomValues(bytes)
    return Array.from(bytes)
      .map((b) => b.toString(16).padStart(2, '0'))
      .join('')
  }

  it('should generate 12 character hex codes', () => {
    for (let i = 0; i < 100; i++) {
      const code = generateInviteCode()
      expect(code).toHaveLength(12)
      expect(code).toMatch(/^[0-9a-f]{12}$/)
    }
  })

  it('should generate unique codes across 10000 iterations', () => {
    const codes = new Set<string>()
    const iterations = 10000

    for (let i = 0; i < iterations; i++) {
      codes.add(generateInviteCode())
    }

    // All codes should be unique (statistically almost certain)
    expect(codes.size).toBe(iterations)
  })

  it('should have sufficient entropy (48 bits)', () => {
    // 6 bytes = 48 bits of entropy
    // Possible combinations: 2^48 = 281,474,976,710,656
    const possibleCombinations = Math.pow(2, 48)
    expect(possibleCombinations).toBeGreaterThan(281_000_000_000_000)
  })
})

describe('UUID Format (Group IDs)', () => {
  // UUID v4 regex pattern
  const UUID_V4_REGEX = /^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i

  const generateUUID = (): string => {
    return crypto.randomUUID()
  }

  it('should generate valid UUID v4 format', () => {
    for (let i = 0; i < 100; i++) {
      const uuid = generateUUID()
      expect(uuid).toMatch(UUID_V4_REGEX)
    }
  })

  it('should generate unique UUIDs across 10000 iterations', () => {
    const uuids = new Set<string>()
    const iterations = 10000

    for (let i = 0; i < iterations; i++) {
      uuids.add(generateUUID())
    }

    expect(uuids.size).toBe(iterations)
  })

  it('should have sufficient entropy (122 bits)', () => {
    // UUID v4 has 122 bits of randomness
    // 6 bits are fixed (version and variant)
    // Possible combinations: 2^122
    const possibleCombinations = Math.pow(2, 122)
    expect(possibleCombinations).toBeGreaterThan(5e36)
  })
})

describe('Invite Code Validation', () => {
  const isValidInviteCode = (code: string): boolean => {
    return /^[0-9a-f]{12}$/i.test(code)
  }

  it('should validate correct invite codes', () => {
    expect(isValidInviteCode('a1b2c3d4e5f6')).toBe(true)
    expect(isValidInviteCode('000000000000')).toBe(true)
    expect(isValidInviteCode('ffffffffffff')).toBe(true)
    expect(isValidInviteCode('ABCDEF123456')).toBe(true) // case insensitive
  })

  it('should reject invalid invite codes', () => {
    expect(isValidInviteCode('')).toBe(false)
    expect(isValidInviteCode('a1b2c3')).toBe(false) // too short
    expect(isValidInviteCode('a1b2c3d4e5f6g7')).toBe(false) // too long
    expect(isValidInviteCode('a1b2c3d4e5g6')).toBe(false) // invalid char 'g'
    expect(isValidInviteCode('a1b2-c3d4-e5f6')).toBe(false) // has dashes
    expect(isValidInviteCode('hello world!')).toBe(false) // invalid chars
  })
})

describe('UUID Validation', () => {
  const isValidUUID = (uuid: string): boolean => {
    return /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i.test(uuid)
  }

  it('should validate correct UUIDs', () => {
    expect(isValidUUID('550e8400-e29b-41d4-a716-446655440000')).toBe(true)
    expect(isValidUUID('6ba7b810-9dad-11d1-80b4-00c04fd430c8')).toBe(true)
    expect(isValidUUID('f47ac10b-58cc-4372-a567-0e02b2c3d479')).toBe(true)
  })

  it('should reject invalid UUIDs', () => {
    expect(isValidUUID('')).toBe(false)
    expect(isValidUUID('not-a-uuid')).toBe(false)
    expect(isValidUUID('550e8400-e29b-41d4-a716')).toBe(false) // too short
    expect(isValidUUID('550e8400e29b41d4a716446655440000')).toBe(false) // no dashes
    expect(isValidUUID('550e8400-e29b-41d4-a716-446655440000-extra')).toBe(false) // extra
  })
})

describe('Collision Probability Analysis', () => {
  it('invite code collision is extremely unlikely with realistic usage', () => {
    // Birthday paradox: P(collision) ≈ 1 - e^(-n²/(2*m))
    // where n = number of codes, m = possible codes

    const possibleCodes = Math.pow(16, 12) // 281 trillion
    const expectedGroups = 10_000 // 10k groups (realistic for small app)

    // Using birthday paradox approximation
    const collisionProbability =
      1 - Math.exp(-(expectedGroups * expectedGroups) / (2 * possibleCodes))

    // With 10k groups, collision probability is essentially 0 (~0.00002%)
    expect(collisionProbability).toBeLessThan(0.000001) // less than 0.0001%
  })

  it('invite code space is large enough for millions of groups', () => {
    // Even with 1 million groups, probability is still very low
    const possibleCodes = Math.pow(16, 12)
    const expectedGroups = 1_000_000

    const collisionProbability =
      1 - Math.exp(-(expectedGroups * expectedGroups) / (2 * possibleCodes))

    // ~0.18% - still very low, and DB UNIQUE constraint prevents actual collisions
    expect(collisionProbability).toBeLessThan(0.01) // less than 1%
  })

  it('UUID collision is virtually impossible', () => {
    const possibleUUIDs = Math.pow(2, 122)
    const expectedGroups = 1_000_000 // 1 million groups

    // With 1 million groups
    const denominator = 2 * possibleUUIDs
    const numerator = expectedGroups * expectedGroups

    // Probability is astronomically small
    expect(numerator / denominator).toBeLessThan(1e-25)
  })

  it('database UNIQUE constraint guarantees no duplicates', () => {
    // Even if the random generator somehow produced a duplicate,
    // the UNIQUE constraint on invite_code column would reject it
    // and the insert would fail, triggering a retry with a new code

    // This is a documentation test - the real protection is in the DB
    const hasUniqueConstraint = true // from schema.sql line 60
    expect(hasUniqueConstraint).toBe(true)
  })
})

describe('URL Safety', () => {
  it('invite codes are URL safe', () => {
    // Hex characters (0-9, a-f) are all URL safe
    const urlSafeChars = /^[0-9a-fA-F]+$/

    for (let i = 0; i < 100; i++) {
      const bytes = new Uint8Array(6)
      crypto.getRandomValues(bytes)
      const code = Array.from(bytes)
        .map((b) => b.toString(16).padStart(2, '0'))
        .join('')

      expect(code).toMatch(urlSafeChars)
      // Should not need encoding
      expect(encodeURIComponent(code)).toBe(code)
    }
  })

  it('UUIDs are URL safe', () => {
    for (let i = 0; i < 100; i++) {
      const uuid = crypto.randomUUID()
      // Should not need encoding (only contains hex chars and dashes)
      expect(encodeURIComponent(uuid)).toBe(uuid)
    }
  })
})
